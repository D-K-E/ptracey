<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Path Tracer: Assimp::SceneCombiner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Path Tracer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceAssimp.html">Assimp</a></li><li class="navelem"><a class="el" href="classAssimp_1_1SceneCombiner.html">SceneCombiner</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classAssimp_1_1SceneCombiner-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Assimp::SceneCombiner Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Static helper class providing various utilities to merge two scenes. It is intended as internal utility and NOT for use by applications.  
 <a href="classAssimp_1_1SceneCombiner.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SceneCombiner_8h_source.html">SceneCombiner.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab399fdea5846bc969a021a39f5a11276"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssimp_1_1SceneCombiner.html#ab399fdea5846bc969a021a39f5a11276">MergeScenes</a> (<a class="el" href="structaiScene.html">aiScene</a> **dest, std::vector&lt; <a class="el" href="structaiScene.html">aiScene</a> * &gt; &amp;src, unsigned int flags=0)</td></tr>
<tr class="separator:ab399fdea5846bc969a021a39f5a11276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49af3c46e42d4da59bb1a488e517618c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssimp_1_1SceneCombiner.html#a49af3c46e42d4da59bb1a488e517618c">MergeScenes</a> (<a class="el" href="structaiScene.html">aiScene</a> **dest, <a class="el" href="structaiScene.html">aiScene</a> *master, std::vector&lt; <a class="el" href="structAssimp_1_1AttachmentInfo.html">AttachmentInfo</a> &gt; &amp;src, unsigned int flags=0)</td></tr>
<tr class="separator:a49af3c46e42d4da59bb1a488e517618c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3486044d9e2213bb8c408d8e8ef906f4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssimp_1_1SceneCombiner.html#a3486044d9e2213bb8c408d8e8ef906f4">MergeMeshes</a> (<a class="el" href="structaiMesh.html">aiMesh</a> **dest, unsigned int flags, std::vector&lt; <a class="el" href="structaiMesh.html">aiMesh</a> * &gt;::const_iterator begin, std::vector&lt; <a class="el" href="structaiMesh.html">aiMesh</a> * &gt;::const_iterator end)</td></tr>
<tr class="separator:a3486044d9e2213bb8c408d8e8ef906f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42d5370510db89cbdd739617a617d4e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssimp_1_1SceneCombiner.html#aa42d5370510db89cbdd739617a617d4e">MergeBones</a> (<a class="el" href="structaiMesh.html">aiMesh</a> *out, std::vector&lt; <a class="el" href="structaiMesh.html">aiMesh</a> * &gt;::const_iterator it, std::vector&lt; <a class="el" href="structaiMesh.html">aiMesh</a> * &gt;::const_iterator end)</td></tr>
<tr class="separator:aa42d5370510db89cbdd739617a617d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebdb2b454f84032f2cfb51ebd7d5716"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssimp_1_1SceneCombiner.html#a9ebdb2b454f84032f2cfb51ebd7d5716">MergeMaterials</a> (<a class="el" href="structaiMaterial.html">aiMaterial</a> **dest, std::vector&lt; <a class="el" href="structaiMaterial.html">aiMaterial</a> * &gt;::const_iterator begin, std::vector&lt; <a class="el" href="structaiMaterial.html">aiMaterial</a> * &gt;::const_iterator end)</td></tr>
<tr class="separator:a9ebdb2b454f84032f2cfb51ebd7d5716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfbbbab2ece2925fc3628c587ea9dcc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssimp_1_1SceneCombiner.html#a9bfbbbab2ece2925fc3628c587ea9dcc">BuildUniqueBoneList</a> (std::list&lt; <a class="el" href="structAssimp_1_1BoneWithHash.html">BoneWithHash</a> &gt; &amp;asBones, std::vector&lt; <a class="el" href="structaiMesh.html">aiMesh</a> * &gt;::const_iterator it, std::vector&lt; <a class="el" href="structaiMesh.html">aiMesh</a> * &gt;::const_iterator end)</td></tr>
<tr class="separator:a9bfbbbab2ece2925fc3628c587ea9dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4ec755bb270b894e37d20938a4a88b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssimp_1_1SceneCombiner.html#a5e4ec755bb270b894e37d20938a4a88b">AddNodePrefixes</a> (<a class="el" href="structaiNode.html">aiNode</a> *node, const char *prefix, unsigned int len)</td></tr>
<tr class="separator:a5e4ec755bb270b894e37d20938a4a88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c52e873dfdd0c71f7f2bae06bcbb865"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssimp_1_1SceneCombiner.html#a0c52e873dfdd0c71f7f2bae06bcbb865">OffsetNodeMeshIndices</a> (<a class="el" href="structaiNode.html">aiNode</a> *node, unsigned int offset)</td></tr>
<tr class="separator:a0c52e873dfdd0c71f7f2bae06bcbb865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1672dc80009a8183edbabc4ef262b5c5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssimp_1_1SceneCombiner.html#a1672dc80009a8183edbabc4ef262b5c5">AttachToGraph</a> (<a class="el" href="structaiScene.html">aiScene</a> *master, std::vector&lt; <a class="el" href="structAssimp_1_1NodeAttachmentInfo.html">NodeAttachmentInfo</a> &gt; &amp;srcList)</td></tr>
<tr class="separator:a1672dc80009a8183edbabc4ef262b5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269f58bf3cd9d0e2841488a83e265785"><td class="memItemLeft" align="right" valign="top"><a id="a269f58bf3cd9d0e2841488a83e265785"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>AttachToGraph</b> (<a class="el" href="structaiNode.html">aiNode</a> *attach, std::vector&lt; <a class="el" href="structAssimp_1_1NodeAttachmentInfo.html">NodeAttachmentInfo</a> &gt; &amp;srcList)</td></tr>
<tr class="separator:a269f58bf3cd9d0e2841488a83e265785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855a472e4848d737ef1ff091363f3a7c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssimp_1_1SceneCombiner.html#a855a472e4848d737ef1ff091363f3a7c">CopyScene</a> (<a class="el" href="structaiScene.html">aiScene</a> **dest, const <a class="el" href="structaiScene.html">aiScene</a> *source, bool allocate=true)</td></tr>
<tr class="separator:a855a472e4848d737ef1ff091363f3a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd836d513bc02da4c40d1432bf687f3e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssimp_1_1SceneCombiner.html#afd836d513bc02da4c40d1432bf687f3e">CopySceneFlat</a> (<a class="el" href="structaiScene.html">aiScene</a> **dest, const <a class="el" href="structaiScene.html">aiScene</a> *source)</td></tr>
<tr class="separator:afd836d513bc02da4c40d1432bf687f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabed196fdfb16f82873ec811c6a64bfc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAssimp_1_1SceneCombiner.html#aabed196fdfb16f82873ec811c6a64bfc">Copy</a> (<a class="el" href="structaiMesh.html">aiMesh</a> **dest, const <a class="el" href="structaiMesh.html">aiMesh</a> *src)</td></tr>
<tr class="separator:aabed196fdfb16f82873ec811c6a64bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcbaaf94a026c06148bccb070a49d09"><td class="memItemLeft" align="right" valign="top"><a id="acfcbaaf94a026c06148bccb070a49d09"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>Copy</b> (<a class="el" href="structaiAnimMesh.html">aiAnimMesh</a> **dest, const <a class="el" href="structaiAnimMesh.html">aiAnimMesh</a> *src)</td></tr>
<tr class="separator:acfcbaaf94a026c06148bccb070a49d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada94b6a9447bcf44b16c26517af347b5"><td class="memItemLeft" align="right" valign="top"><a id="ada94b6a9447bcf44b16c26517af347b5"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>Copy</b> (<a class="el" href="structaiMaterial.html">aiMaterial</a> **dest, const <a class="el" href="structaiMaterial.html">aiMaterial</a> *src)</td></tr>
<tr class="separator:ada94b6a9447bcf44b16c26517af347b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a28e4264b5449e8fa789b07649f105d"><td class="memItemLeft" align="right" valign="top"><a id="a5a28e4264b5449e8fa789b07649f105d"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>Copy</b> (<a class="el" href="structaiTexture.html">aiTexture</a> **dest, const <a class="el" href="structaiTexture.html">aiTexture</a> *src)</td></tr>
<tr class="separator:a5a28e4264b5449e8fa789b07649f105d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d3dfc83ee46803849e3c72ba5b3f41"><td class="memItemLeft" align="right" valign="top"><a id="af9d3dfc83ee46803849e3c72ba5b3f41"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>Copy</b> (<a class="el" href="structaiAnimation.html">aiAnimation</a> **dest, const <a class="el" href="structaiAnimation.html">aiAnimation</a> *src)</td></tr>
<tr class="separator:af9d3dfc83ee46803849e3c72ba5b3f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b898d651efd801cbd13c55af0cc9e0f"><td class="memItemLeft" align="right" valign="top"><a id="a7b898d651efd801cbd13c55af0cc9e0f"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>Copy</b> (<a class="el" href="structaiCamera.html">aiCamera</a> **dest, const <a class="el" href="structaiCamera.html">aiCamera</a> *src)</td></tr>
<tr class="separator:a7b898d651efd801cbd13c55af0cc9e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e36195e75b13510f1d81e6b0bc53778"><td class="memItemLeft" align="right" valign="top"><a id="a9e36195e75b13510f1d81e6b0bc53778"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>Copy</b> (<a class="el" href="structaiBone.html">aiBone</a> **dest, const <a class="el" href="structaiBone.html">aiBone</a> *src)</td></tr>
<tr class="separator:a9e36195e75b13510f1d81e6b0bc53778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa124aea5032357294ecbe48f572611"><td class="memItemLeft" align="right" valign="top"><a id="a4fa124aea5032357294ecbe48f572611"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>Copy</b> (<a class="el" href="structaiLight.html">aiLight</a> **dest, const <a class="el" href="structaiLight.html">aiLight</a> *src)</td></tr>
<tr class="separator:a4fa124aea5032357294ecbe48f572611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbebe1cefa45eece9ebe4bcd8c7e3e65"><td class="memItemLeft" align="right" valign="top"><a id="afbebe1cefa45eece9ebe4bcd8c7e3e65"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>Copy</b> (<a class="el" href="structaiNodeAnim.html">aiNodeAnim</a> **dest, const <a class="el" href="structaiNodeAnim.html">aiNodeAnim</a> *src)</td></tr>
<tr class="separator:afbebe1cefa45eece9ebe4bcd8c7e3e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f8edf157fec67f0c49c363ec37bad7"><td class="memItemLeft" align="right" valign="top"><a id="a55f8edf157fec67f0c49c363ec37bad7"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>Copy</b> (<a class="el" href="structaiMeshMorphAnim.html">aiMeshMorphAnim</a> **dest, const <a class="el" href="structaiMeshMorphAnim.html">aiMeshMorphAnim</a> *src)</td></tr>
<tr class="separator:a55f8edf157fec67f0c49c363ec37bad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a442fed79eda7f99852a3daa064a0b"><td class="memItemLeft" align="right" valign="top"><a id="a70a442fed79eda7f99852a3daa064a0b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>Copy</b> (<a class="el" href="structaiMetadata.html">aiMetadata</a> **dest, const <a class="el" href="structaiMetadata.html">aiMetadata</a> *src)</td></tr>
<tr class="separator:a70a442fed79eda7f99852a3daa064a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b44e00c4bab88e9c84f0a53ad14e29"><td class="memItemLeft" align="right" valign="top"><a id="ac6b44e00c4bab88e9c84f0a53ad14e29"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>Copy</b> (<a class="el" href="structaiNode.html">aiNode</a> **dest, const <a class="el" href="structaiNode.html">aiNode</a> *src)</td></tr>
<tr class="separator:ac6b44e00c4bab88e9c84f0a53ad14e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Static helper class providing various utilities to merge two scenes. It is intended as internal utility and NOT for use by applications. </p>
<p>The class is currently being used by various postprocessing steps and loaders (ie. LWS). </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a5e4ec755bb270b894e37d20938a4a88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4ec755bb270b894e37d20938a4a88b">&#9670;&nbsp;</a></span>AddNodePrefixes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::AddNodePrefixes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaiNode.html">aiNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a name prefix to all nodes in a scene.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Current</td><td>node. This function is called recursively. </td></tr>
    <tr><td class="paramname">prefix</td><td>Prefix to be added to all nodes </td></tr>
    <tr><td class="paramname">len</td><td>STring length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1672dc80009a8183edbabc4ef262b5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1672dc80009a8183edbabc4ef262b5c5">&#9670;&nbsp;</a></span>AttachToGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::AttachToGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaiScene.html">aiScene</a> *&#160;</td>
          <td class="paramname"><em>master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structAssimp_1_1NodeAttachmentInfo.html">NodeAttachmentInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attach a list of node graphs to well-defined nodes in a master graph. This is a helper for <a class="el" href="classAssimp_1_1SceneCombiner.html#ab399fdea5846bc969a021a39f5a11276">MergeScenes()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">master</td><td>Master scene </td></tr>
    <tr><td class="paramname">srcList</td><td>List of source scenes along with their attachment points. If an attachment point is nullptr (or does not exist in the master graph), a scene is attached to the root of the master graph (as an additional child node) @duplicates List of duplicates. If elem[n] == n the scene is not a duplicate. Otherwise elem[n] links scene n to its first occurrence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bfbbbab2ece2925fc3628c587ea9dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfbbbab2ece2925fc3628c587ea9dcc">&#9670;&nbsp;</a></span>BuildUniqueBoneList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::BuildUniqueBoneList </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; <a class="el" href="structAssimp_1_1BoneWithHash.html">BoneWithHash</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>asBones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structaiMesh.html">aiMesh</a> * &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structaiMesh.html">aiMesh</a> * &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Builds a list of uniquely named bones in a mesh list</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asBones</td><td>Receives the output list </td></tr>
    <tr><td class="paramname">it</td><td>First mesh to be processed </td></tr>
    <tr><td class="paramname">end</td><td>Last mesh to be processed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabed196fdfb16f82873ec811c6a64bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabed196fdfb16f82873ec811c6a64bfc">&#9670;&nbsp;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::Copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaiMesh.html">aiMesh</a> **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structaiMesh.html">aiMesh</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a deep copy of a mesh</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Receives a pointer to the destination mesh </td></tr>
    <tr><td class="paramname">src</td><td>Source mesh - remains unmodified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a855a472e4848d737ef1ff091363f3a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855a472e4848d737ef1ff091363f3a7c">&#9670;&nbsp;</a></span>CopyScene()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::CopyScene </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaiScene.html">aiScene</a> **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structaiScene.html">aiScene</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allocate</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a deep copy of a scene</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Receives a pointer to the destination scene </td></tr>
    <tr><td class="paramname">src</td><td>Source scene - remains unmodified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd836d513bc02da4c40d1432bf687f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd836d513bc02da4c40d1432bf687f3e">&#9670;&nbsp;</a></span>CopySceneFlat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::CopySceneFlat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaiScene.html">aiScene</a> **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structaiScene.html">aiScene</a> *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a flat copy of a scene</p>
<p>Only the first hierarchy layer is copied. All pointer members of <a class="el" href="structaiScene.html">aiScene</a> are shared by source and destination scene. If the pointer doesn't point to nullptr when the function is called, the existing scene is cleared and refilled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Receives a pointer to the destination scene </td></tr>
    <tr><td class="paramname">src</td><td>Source scene - remains unmodified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa42d5370510db89cbdd739617a617d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42d5370510db89cbdd739617a617d4e">&#9670;&nbsp;</a></span>MergeBones()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::MergeBones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaiMesh.html">aiMesh</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structaiMesh.html">aiMesh</a> * &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structaiMesh.html">aiMesh</a> * &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges two or more bones</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Mesh to receive the output bone list </td></tr>
    <tr><td class="paramname">flags</td><td>Currently no parameters </td></tr>
    <tr><td class="paramname">begin</td><td>First mesh to be processed </td></tr>
    <tr><td class="paramname">end</td><td>Points to the mesh after the last mesh to be processed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ebdb2b454f84032f2cfb51ebd7d5716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ebdb2b454f84032f2cfb51ebd7d5716">&#9670;&nbsp;</a></span>MergeMaterials()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::MergeMaterials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaiMaterial.html">aiMaterial</a> **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structaiMaterial.html">aiMaterial</a> * &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structaiMaterial.html">aiMaterial</a> * &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges two or more materials</p>
<p>The materials should be complementary as much as possible. In case of a property present in different materials, the first occurrence is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Destination material. Must be empty. </td></tr>
    <tr><td class="paramname">begin</td><td>First material to be processed </td></tr>
    <tr><td class="paramname">end</td><td>Points to the material after the last material to be processed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3486044d9e2213bb8c408d8e8ef906f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3486044d9e2213bb8c408d8e8ef906f4">&#9670;&nbsp;</a></span>MergeMeshes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::MergeMeshes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaiMesh.html">aiMesh</a> **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structaiMesh.html">aiMesh</a> * &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structaiMesh.html">aiMesh</a> * &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges two or more meshes</p>
<p>The meshes should have equal vertex formats. Only components that are provided by ALL meshes will be present in the output mesh. An exception is made for VColors - they are set to black. The meshes should have the same material indices, too. The output material index is always the material index of the first mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Destination mesh. Must be empty. </td></tr>
    <tr><td class="paramname">flags</td><td>Currently no parameters </td></tr>
    <tr><td class="paramname">begin</td><td>First mesh to be processed </td></tr>
    <tr><td class="paramname">end</td><td>Points to the mesh after the last mesh to be processed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49af3c46e42d4da59bb1a488e517618c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49af3c46e42d4da59bb1a488e517618c">&#9670;&nbsp;</a></span>MergeScenes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::MergeScenes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaiScene.html">aiScene</a> **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structaiScene.html">aiScene</a> *&#160;</td>
          <td class="paramname"><em>master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structAssimp_1_1AttachmentInfo.html">AttachmentInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges two or more scenes and attaches all scenes to a specific position in the node graph of the master scene.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Receives a pointer to the destination scene. If the pointer doesn't point to nullptr when the function is called, the existing scene is cleared and refilled. </td></tr>
    <tr><td class="paramname">master</td><td>Master scene. It will be deleted afterwards. All other scenes will be inserted in its node graph. </td></tr>
    <tr><td class="paramname">src</td><td>Non-empty list of scenes to be merged along with their corresponding attachment points in the master scene. The function deletes the input scenes afterwards. There may be duplicate scenes. </td></tr>
    <tr><td class="paramname">flags</td><td>Combination of the AI_INT_MERGE_SCENE flags defined above </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab399fdea5846bc969a021a39f5a11276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab399fdea5846bc969a021a39f5a11276">&#9670;&nbsp;</a></span>MergeScenes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::MergeScenes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaiScene.html">aiScene</a> **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structaiScene.html">aiScene</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges two or more scenes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Receives a pointer to the destination scene. If the pointer doesn't point to nullptr when the function is called, the existing scene is cleared and refilled. </td></tr>
    <tr><td class="paramname">src</td><td>Non-empty list of scenes to be merged. The function deletes the input scenes afterwards. There may be duplicate scenes. </td></tr>
    <tr><td class="paramname">flags</td><td>Combination of the AI_INT_MERGE_SCENE flags defined above </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c52e873dfdd0c71f7f2bae06bcbb865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c52e873dfdd0c71f7f2bae06bcbb865">&#9670;&nbsp;</a></span>OffsetNodeMeshIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::OffsetNodeMeshIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaiNode.html">aiNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an offset to all mesh indices in a node graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Current</td><td>node. This function is called recursively. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset to be added to all mesh indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SceneCombiner_8h_source.html">SceneCombiner.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.19
</small></address>
</body>
</html>
